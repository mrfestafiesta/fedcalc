<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Ultimate Outdoor Tracker</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        /* --- LAYOUT --- */
        body { margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; background: #000; font-family: sans-serif; overflow: hidden; }
        
        /* --- CAMERA SECTION (Top Half) --- */
        #camera-container {
            flex: 1; /* Takes up 50% of screen */
            position: relative;
            overflow: hidden;
            background: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fills the box without stretching */
            display: none; 
        }
        video.active { display: block; }

        /* --- AR OVERLAY (The Floating Label) --- */
        #ar-overlay {
            position: absolute;
            top: 40%; 
            left: 50%; /* Default center */
            transform: translate(-50%, -50%);
            display: none; 
            pointer-events: none; /* Let clicks pass through */
            text-align: center;
            transition: left 0.1s linear; /* Smooth movement */
            z-index: 10;
        }
        
        .ar-bubble {
            background: rgba(40, 167, 69, 0.9); /* Green */
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border: 2px solid white;
            white-space: nowrap;
        }
        
        .ar-dist { 
            font-size: 14px; 
            margin-top: 5px; 
            text-shadow: 0 1px 2px black; 
            color: #fff; 
            font-weight: bold;
        }

        /* --- DIAGNOSTIC BOX (Yellow Debugger) --- */
        #debug-console {
            position: absolute; 
            top: 60px; 
            left: 10px; 
            background: rgba(255, 255, 0, 0.8); 
            color: black; 
            padding: 8px; 
            font-size: 11px; 
            z-index: 2000; 
            font-family: monospace; 
            pointer-events: none;
            border-radius: 4px;
            display: none; /* Hidden by default, code turns it on */
        }

        /* --- MAP SECTION (Bottom Half) --- */
        #map { flex: 1; width: 100%; }

        /* --- UI OVERLAYS --- */
        #status {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.6); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 12px;
            z-index: 1000; pointer-events: none; white-space: pre-line;
        }

        #controls {
            position: absolute; bottom: 20px; left: 20px;
            z-index: 1000; display: flex; flex-direction: column; gap: 10px; align-items: flex-start;
        }

        #data-display {
            background: rgba(0, 0, 0, 0.7); padding: 8px 15px; border-radius: 15px;
            margin-bottom: 5px; color: white; display: flex; flex-direction: column; min-width: 140px;
        }
        .data-row { display: flex; justify-content: space-between; align-items: center; font-size: 14px; margin-bottom: 4px; }
        .data-val { font-weight: bold; font-family: monospace; font-size: 16px; }

        /* --- BUTTONS --- */
        .pill-btn {
            background-color: #444; color: white; border: none; padding: 12px 20px;
            border-radius: 50px; font-size: 14px; font-weight: bold; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); text-align: center; width: 160px; 
            transition: background-color 0.2s;
        }
        .pill-btn.active { background-color: #28a745; }
        
        #btn-reset {
            background: #d9534f; color: white; border: none; border-radius: 4px;
            padding: 4px 8px; font-size: 11px; cursor: pointer; margin-top: 5px; align-self: flex-end;
        }

        /* --- CHART MODAL --- */
        #chart-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 3000;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #chart-container { width: 95%; height: 50%; background: white; border-radius: 8px; padding: 10px; }
        #close-chart {
            margin-top: 20px; padding: 10px 30px; background: white; border: none;
            font-weight: bold; border-radius: 50px; cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="status">Initializing System...</div>
    
    <div id="debug-console">Waiting for GPS/Compass...</div>

    <div id="camera-container">
        <span id="camera-placeholder">Camera Paused</span>
        <video id="video-feed" autoplay playsinline muted></video>
        
        <div id="ar-overlay">
            <div id="ar-text" class="ar-bubble">Target</div>
            <div id="ar-dist" class="ar-dist">0 ft away</div>
        </div>
    </div>

    <div id="map"></div>

    <div id="controls">
        <div id="data-display">
            <div class="data-row"><span>Dist:</span><span id="dist-val" class="data-val">0.0 ft</span></div>
            <div class="data-row"><span>Elev:</span><span id="elev-val" class="data-val">-- ft</span></div>
            <button id="btn-reset">RESET TRIP</button>
        </div>

        <button id="btn-compass" class="pill-btn">Enable Compass</button>
        <button id="btn-graph" class="pill-btn">Show Elevation</button>
        <button id="btn-cam" class="pill-btn">Camera Off</button>
        <button id="btn-path" class="pill-btn">GPS Path Off</button>
    </div>

    <div id="chart-modal">
        <div id="chart-container"><canvas id="elevationChart"></canvas></div>
        <button id="close-chart">Close Graph</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script type="module">
        import { get, set, del } from 'https://unpkg.com/idb-keyval@6.2.1/dist/index.js';

        // ==========================================
        // --- CONFIGURATION: EDIT THIS SECTION ---
        // ==========================================
        
        // 1. THE AR TARGET (Where the floating bubble points to)
        const AR_TARGET = { 
            lat: 34.0522,   // <--- CHANGE THIS LATITUDE
            lng: -118.2437, // <--- CHANGE THIS LONGITUDE
            name: "My House"
        };

        // 2. OTHER MAP MARKERS (Standard pins)
        const POI_LIST = [
            { lat: 34.0540, lng: -118.2450, name: "Big Oak Tree" },
            { lat: 34.0550, lng: -118.2460, name: "Park Entrance" }
        ];

        // ==========================================


        // --- STATE VARIABLES ---
        let latestFix = null;       // { lat, lng, alt, acc }
        let lastLoggedFix = null;   // For distance calc
        let deviceHeading = 0;      // Compass 0-360
        
        let fullPathData = [];      // Array of [lat, lng, alt, time]
        let totalDistanceFeet = 0;
        
        let isCameraOn = false;
        let isPathOn = false;
        let currentStream = null;
        let myChart = null;

        // --- DOM ELEMENTS ---
        const statusDiv = document.getElementById('status');
        const debugDiv = document.getElementById('debug-console');
        const arOverlay = document.getElementById('ar-overlay');
        const arText = document.getElementById('ar-text');
        const arDist = document.getElementById('ar-dist');
        
        const btnCompass = document.getElementById('btn-compass');
        const btnCam = document.getElementById('btn-cam');
        const btnPath = document.getElementById('btn-path');
        const btnReset = document.getElementById('btn-reset');
        const btnGraph = document.getElementById('btn-graph');
        const videoElement = document.getElementById('video-feed');
        const camPlaceholder = document.getElementById('camera-placeholder');
        const distVal = document.getElementById('dist-val');
        const elevVal = document.getElementById('elev-val');
        const chartModal = document.getElementById('chart-modal');
        const btnCloseChart = document.getElementById('close-chart');

        // --- SECTION 1: MAP SETUP ---
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' }).addTo(map);
        
        const userMarker = L.marker([0, 0]).addTo(map);
        const pathLine = L.polyline([], {color: 'red'}).addTo(map);
        const dotLayer = L.layerGroup().addTo(map); // Container for orange dots

        // Add AR Target Pin (Red)
        L.marker([AR_TARGET.lat, AR_TARGET.lng]).addTo(map).bindPopup(`<b>${AR_TARGET.name}</b><br>(AR Target)`);
        
        // Add Other Pins (Blue)
        POI_LIST.forEach(poi => {
            L.marker([poi.lat, poi.lng]).addTo(map).bindPopup(`<b>${poi.name}</b>`);
        });


        // --- SECTION 2: COMPASS & AR LOGIC ---
        btnCompass.addEventListener('click', () => {
            // iOS 13+ Permissions
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            btnCompass.style.display = 'none';
                            debugDiv.style.display = 'block'; // Show debug box
                        } else { alert("Permission denied"); }
                    })
                    .catch(console.error);
            } else {
                // Android/Non-iOS
                window.addEventListener('deviceorientation', handleOrientation);
                btnCompass.style.display = 'none';
                debugDiv.style.display = 'block';
            }
        });

        function handleOrientation(event) {
            let heading = 0;
            // iOS (Webkit)
            if (event.webkitCompassHeading) {
                heading = event.webkitCompassHeading;
            } 
            // Android (Standard)
            else if (event.alpha !== null) {
                heading = 360 - event.alpha; 
            }
            deviceHeading = heading;
            updateAR(); 
        }

        function updateAR() {
            if (!latestFix || !isCameraOn) return;

            const userLoc = L.latLng(latestFix.lat, latestFix.lng);
            const poiLoc = L.latLng(AR_TARGET.lat, AR_TARGET.lng);
            
            // 1. Distance
            const distMeters = userLoc.distanceTo(poiLoc);
            const distFeet = distMeters * 3.28084;

            // 2. Bearing (Angle to target)
            const y = Math.sin(poiLoc.lng * Math.PI/180 - userLoc.lng * Math.PI/180) * Math.cos(poiLoc.lat * Math.PI/180);
            const x = Math.cos(userLoc.lat * Math.PI/180) * Math.sin(poiLoc.lat * Math.PI/180) -
                    Math.sin(userLoc.lat * Math.PI/180) * Math.cos(poiLoc.lat * Math.PI/180) * Math.cos(poiLoc.lng * Math.PI/180 - userLoc.lng * Math.PI/180);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360; 

            // 3. Difference (Where to put on screen)
            let diff = bearing - deviceHeading;
            // Normalize (-180 to 180)
            while (diff < -180) diff += 360;
            while (diff > 180) diff -= 360;

            // --- DEBUG OUTPUT ---
            debugDiv.innerHTML = `
                <b>DEBUG MODE</b><br>
                Target: ${AR_TARGET.name}<br>
                Dist: ${distFeet.toFixed(0)} ft <br>
                Bearing: ${bearing.toFixed(0)}°<br>
                Phone Hdg: ${deviceHeading.toFixed(0)}°<br>
                Diff: ${diff.toFixed(0)}°
            `;

            // --- VISUAL LOGIC ---
            // Show if within 2000ft (Generous range for testing)
            if (distFeet < 2000) {
                arOverlay.style.display = 'block';
                arText.innerText = AR_TARGET.name;
                arDist.innerText = distFeet.toFixed(0) + " ft";
                
                // Clamp to screen edges (5% to 95%)
                // Multiplier 1.5 makes it move faster than your turn
                let screenPercent = 50 + (diff * 1.5);
                if (screenPercent < 5) screenPercent = 5;
                if (screenPercent > 95) screenPercent = 95;

                arOverlay.style.left = screenPercent + "%";
                
                // Indicator: If diff > 45, make transparent to suggest "Turn more"
                if (Math.abs(diff) > 45) {
                    arOverlay.style.opacity = "0.5"; 
                } else {
                    arOverlay.style.opacity = "1.0";
                }

            } else {
                arOverlay.style.display = 'none';
            }
        }


        // --- SECTION 3: STANDARD LOGIC (Camera, GPS, DB) ---
        
        // Load Old Data
        async function loadSavedTrip() {
            try {
                const savedPath = await get('my-hike-data');
                if (savedPath && savedPath.length > 0) {
                    fullPathData = savedPath;
                    const latLngs = fullPathData.map(p => [p[0], p[1]]);
                    pathLine.setLatLngs(latLngs);
                    latLngs.forEach(pt => L.circleMarker(pt, {radius: 4, color: 'orange', fillColor: '#f03', fillOpacity: 0.8}).addTo(dotLayer));

                    let restoredDist = 0;
                    for(let i=1; i<latLngs.length; i++) {
                        restoredDist += map.distance(latLngs[i-1], latLngs[i]);
                    }
                    totalDistanceFeet = restoredDist * 3.28084;
                    distVal.innerText = `${totalDistanceFeet.toFixed(1)} ft`;
                    
                    const lastPoint = fullPathData[fullPathData.length - 1];
                    lastLoggedFix = { lat: lastPoint[0], lng: lastPoint[1] };
                    map.setView([lastPoint[0], lastPoint[1]], 16);
                }
            } catch (err) { console.error(err); }
        }
        loadSavedTrip();

        // Camera Toggle
        btnCam.addEventListener('click', async () => {
            if (!isCameraOn) {
                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    videoElement.srcObject = currentStream;
                    videoElement.classList.add('active');
                    camPlaceholder.style.display = 'none';
                    isCameraOn = true;
                    btnCam.textContent = "Camera On";
                    btnCam.classList.add('active');
                } catch (err) { alert("Camera failed."); }
            } else {
                if (currentStream) currentStream.getTracks().forEach(t => t.stop());
                videoElement.srcObject = null;
                videoElement.classList.remove('active');
                camPlaceholder.style.display = 'block';
                isCameraOn = false;
                btnCam.textContent = "Camera Off";
                btnCam.classList.remove('active');
                arOverlay.style.display = 'none'; 
            }
        });

        // GPS Watcher
        if (navigator.geolocation) {
            navigator.geolocation.watchPosition(
                (pos) => {
                    latestFix = { lat: pos.coords.latitude, lng: pos.coords.longitude, alt: pos.coords.altitude || 0, acc: pos.coords.accuracy };
                    userMarker.setLatLng([latestFix.lat, latestFix.lng]);
                    
                    const altFeet = (latestFix.alt * 3.28084).toFixed(0);
                    statusDiv.innerText = `GPS Active\nAcc: ${latestFix.acc.toFixed(0)}m`;
                    elevVal.innerText = `${altFeet} ft`;
                    
                    updateAR(); // Update AR position on GPS move too
                },
                (err) => statusDiv.innerText = "Waiting for GPS...",
                { enableHighAccuracy: true, maximumAge: 0 }
            );
        }

        // Recording Toggle
        btnPath.addEventListener('click', () => {
            isPathOn = !isPathOn;
            if (isPathOn) {
                btnPath.textContent = "Recording...";
                btnPath.classList.add('active');
                if (!lastLoggedFix && latestFix) lastLoggedFix = latestFix;
            } else {
                btnPath.textContent = "GPS Path Off";
                btnPath.classList.remove('active');
            }
        });

        // Reset Logic
        btnReset.addEventListener('click', async () => {
            if(!confirm("Delete all saved path data?")) return;
            fullPathData = []; totalDistanceFeet = 0; pathLine.setLatLngs([]); 
            dotLayer.clearLayers();
            distVal.innerText = "0.0 ft"; lastLoggedFix = null;
            await del('my-hike-data');
            alert("Trip reset.");
        });

        // Chart Logic
        btnGraph.addEventListener('click', () => {
             if (fullPathData.length < 2) { alert("Not enough data to graph yet."); return; }
             
             // Calculate Data
             const labels = [];
             const dataPoints = [];
             let accumDist = 0;
             for (let i = 0; i < fullPathData.length; i++) {
                const point = fullPathData[i];
                if (i > 0) {
                    const prev = fullPathData[i-1];
                    const distMeters = map.distance([prev[0], prev[1]], [point[0], point[1]]);
                    accumDist += (distMeters * 3.28084);
                }
                labels.push(accumDist.toFixed(0));
                dataPoints.push((point[2] * 3.28084)); // Altitude
             }

             const ctx = document.getElementById('elevationChart').getContext('2d');
             if (myChart) myChart.destroy();
             
             myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Elevation (ft)',
                        data: dataPoints,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        fill: true, tension: 0.3
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { x: { title: { display: true, text: 'Distance (ft)' } }, y: { title: { display: true, text: 'Altitude (ft)' } } }
                }
             });
             chartModal.style.display = 'flex';
        });

        btnCloseChart.addEventListener('click', () => { chartModal.style.display = 'none'; });

        // 5-Second Timer Loop
        setInterval(async () => {
            if (latestFix && isPathOn) {
                if (lastLoggedFix) {
                    const from = L.latLng(lastLoggedFix.lat, lastLoggedFix.lng);
                    const to = L.latLng(latestFix.lat, latestFix.lng);
                    const distFeet = from.distanceTo(to) * 3.28084;
                    if (distFeet > 3) {
                        totalDistanceFeet += distFeet;
                        distVal.innerText = `${totalDistanceFeet.toFixed(1)} ft`;
                    }
                }
                fullPathData.push([latestFix.lat, latestFix.lng, latestFix.alt, Date.now()]);
                await set('my-hike-data', fullPathData);
                
                L.circleMarker([latestFix.lat, latestFix.lng], {radius: 4, color: 'orange', fillColor: '#f03', fillOpacity: 0.8}).addTo(dotLayer);
                
                const simplePath = fullPathData.map(p => [p[0], p[1]]);
                pathLine.setLatLngs(simplePath);
                lastLoggedFix = latestFix;
            }
        }, 5000);

    </script>
</body>
</html>
